@startuml
hide circle
top to bottom direction
scale 0.2

!define ENTITY(x) class x << Entity >>
!define AGGREGATE_ROOT(x) class x << Aggregate Root >>
!define VALUE_OBJECT(x) class x << Value Object >>
!define ENUM(x) class x << Enum >>
!pragma useVerticalIf on

skinparam dpi 350
skinparam packageStyle rectangle
skinparam rectangle {
  BackgroundColor #f7f4eb
  BorderColor Black
}
skinparam class {
  BackgroundColor White
  BorderColor Black
}
skinparam stereotypeCBackgroundColor #e0e0e0
skinparam stereotypeCBorderColor Black

skinparam defaultFontName "Segoe UI"
skinparam defaultFontSize 16
skinparam classFontSize 16
skinparam noteFontSize 14
skinparam packageTitleFontSize 18
skinparam titleFontSize 22

rectangle "CourtierPro Domain" as Domain {

  '======================
  ' USER MANAGEMENT CONTEXT
  '======================
  package "User Management" as UserBC <<Rectangle>> #LightBlue {

    AGGREGATE_ROOT(Client) #lightblue {
      clientId: UUID
      auth0Sub: Auth0SubjectId
      fullName: String
      email: Email
      phone: Phone
      communicationPreferences: CommunicationPreferences
      status: ClientStatusEnum
    }

    AGGREGATE_ROOT(Broker) #lightblue {
      brokerId: UUID
      auth0Sub: Auth0SubjectId
      fullName: String
      licenseNumber: String
      email: Email
      phone: Phone
      active: Boolean
    }

    AGGREGATE_ROOT(Admin) #lightblue {
      adminId: UUID
      auth0Sub: Auth0SubjectId
      fullName: String
      email: Email
      role: AdminRoleEnum
      active: Boolean
    }

    AGGREGATE_ROOT(OrganizationSettings) #lightblue {
      orgId: UUID
      defaultLanguage: LanguageEnum
    }

    VALUE_OBJECT(ClientIdentifier) #Bisque {
      clientId: UUID
    }

    VALUE_OBJECT(BrokerIdentifier) #Bisque {
      brokerId: UUID
    }

    VALUE_OBJECT(AdminIdentifier) #Bisque {
      adminId: UUID
    }

    VALUE_OBJECT(Auth0SubjectId) #Bisque {
      value: String
    }

    VALUE_OBJECT(Email) #Bisque {
      value: String
    }

    VALUE_OBJECT(Phone) #Bisque {
      value: String
    }

    VALUE_OBJECT(CommunicationPreferences) #Bisque {
      emailAllowed: Boolean
      preferredLanguage: LanguageEnum
    }

    ENUM(LanguageEnum) {
      EN
      FR
    }

    ENUM(ClientStatusEnum) {
      ACTIVE
      INACTIVE
      CLOSED
    }

    ENUM(AdminRoleEnum) {
      SYSTEM_ADMIN
      OFFICE_ADMIN
    }

    ' Intra-context links
    Client "1" *-- "1" ClientIdentifier
    Client "1" *-- "1" Auth0SubjectId
    Client "1" *-- "1" Email
    Client "0..1" *-- "1" Phone
    Client "0..1" *-- "1" CommunicationPreferences
    Client --> ClientStatusEnum

    Broker "1" *-- "1" BrokerIdentifier
    Broker "1" *-- "1" Auth0SubjectId
    Broker "1" *-- "1" Email
    Broker "0..1" *-- "1" Phone

    Admin "1" *-- "1" AdminIdentifier
    Admin "1" *-- "1" Auth0SubjectId
    Admin "1" *-- "1" Email
    Admin --> AdminRoleEnum

    CommunicationPreferences --> LanguageEnum
    OrganizationSettings --> LanguageEnum

    note bottom of Client
      Invariants:
      • email must be unique per Client.
      • communicationPreferences.preferredLanguage ∈ {EN, FR} when present.
      • status reflects the ongoing business relationship state.
    end note

    note bottom of Broker
      Invariants:
      • Each Broker must have a valid licenseNumber.
      • active = false means they cannot open new Transactions.
    end note

    note bottom of Admin
      Invariants:
      • Admin manages system configuration and access control.
      • Admin does NOT modify transaction stages on behalf of brokers.
    end note

    note bottom of OrganizationSettings
      Represents system-wide configuration managed by
      Admins (default language, templates).
    end note
  }


  '======================
  ' TRANSACTION MANAGEMENT CONTEXT
  '======================
  package "Transaction Management" as TransactionBC <<Rectangle>> #LightYellow {

    AGGREGATE_ROOT(Transaction) #lightyellow {
      transactionId: UUID
      propertyAddress: PropertyAddress
      clientRef: ClientRef
      brokerRef: BrokerRef
      side: TransactionSideEnum
      buyerStage: BuyerTransactionStageEnum?
      sellerStage: SellerTransactionStageEnum?
      timeline: List<TimelineEntry>
      openedAt: DateTime
      closedAt: DateTime
      status: TransactionStatusEnum
    }

    ENTITY(TimelineEntry) #lightpink {
      timelineEntryId: UUID
      type: TimelineEntryTypeEnum
      note: String
      occurredAt: DateTime
      addedByBrokerId: UUID
      buyerStage: BuyerTransactionStageEnum?
      sellerStage: SellerTransactionStageEnum?
    }

    VALUE_OBJECT(TransactionIdentifier) #Bisque {
      transactionId: UUID
    }

    VALUE_OBJECT(ClientRef) #Bisque {
      clientId: UUID
      snapshotName: String
      snapshotEmail: String
    }

    VALUE_OBJECT(BrokerRef) #Bisque {
      brokerId: UUID
      snapshotName: String
      snapshotLicenseNumber: String
    }

    VALUE_OBJECT(PropertyAddress) #Bisque {
      street: String
      city: String
      province: String
      postalCode: String
    }

    ENUM(TransactionSideEnum) {
      BUY_SIDE
      SELL_SIDE
    }

    ENUM(BuyerTransactionStageEnum) {
      BUYER_PREQUALIFY_FINANCIALLY
      BUYER_SHOP_FOR_PROPERTY
      BUYER_SUBMIT_OFFER
      BUYER_OFFER_ACCEPTED
      BUYER_HOME_INSPECTION
      BUYER_FINANCING_FINALIZED
      BUYER_FIRST_NOTARY_APPOINTMENT
      BUYER_SECOND_NOTARY_APPOINTMENT
      BUYER_OCCUPANCY
      BUYER_TERMINATED
    }

    ENUM(SellerTransactionStageEnum) {
      SELLER_INITIAL_CONSULTATION
      SELLER_LISTING_PUBLISHED
      SELLER_REVIEW_OFFERS
      SELLER_ACCEPT_BEST_OFFER
      SELLER_CONDITIONS_MET
      SELLER_NOTARY_COORDINATION
      SELLER_NOTARY_APPOINTMENT
      SELLER_HANDOVER_KEYS
      SELLER_TERMINATED
    }

    ENUM(TransactionStatusEnum) {
      ACTIVE
      CLOSED_SUCCESSFULLY
      TERMINATED_EARLY
    }

    ENUM(TimelineEntryTypeEnum) {
      STAGE_CHANGE
      NOTE
    }

    ' Intra-context links
    Transaction "1" *-- "1" TransactionIdentifier
    Transaction "1" *-- "1" PropertyAddress
    Transaction "1" *-- "1" ClientRef
    Transaction "1" *-- "1" BrokerRef
    Transaction "1" *-- "0..*" TimelineEntry
    Transaction --> TransactionSideEnum
    Transaction --> BuyerTransactionStageEnum
    Transaction --> SellerTransactionStageEnum
    Transaction --> TransactionStatusEnum

    TimelineEntry --> TimelineEntryTypeEnum
    TimelineEntry --> BuyerTransactionStageEnum
    TimelineEntry --> SellerTransactionStageEnum

    note bottom of Transaction
      Invariants:
      • Each Transaction belongs to exactly one Client and is
        primarily handled by exactly one Broker.
      • side determines whether buyerStage or sellerStage is used:
        - side = BUY_SIDE  → buyerStage must be non-null and define the current step.
        - side = SELL_SIDE → sellerStage must be non-null and define the current step.
      • At most one of buyerStage / sellerStage is non-null at any time.
      • Stage progression must respect the ordered sequence defined by
        the corresponding BuyerTransactionStageEnum or SellerTransactionStageEnum.
      • closedAt is only set when status ∈ {CLOSED_SUCCESSFULLY, TERMINATED_EARLY}.
      • When status = CLOSED_SUCCESSFULLY:
        - BUY_SIDE  → buyerStage must be BUYER_OCCUPANCY.
        - SELL_SIDE → sellerStage must be SELLER_HANDOVER_KEYS.
    end note

    note bottom of TimelineEntry
      Invariants:
      • occurredAt must be immutable once recorded.
      • addedByBrokerId must refer to a valid, active Broker.
      • When type = STAGE_CHANGE, exactly one of buyerStage / sellerStage
        must be non-null and valid for the Transaction.side at the time
        of the change.
      • When type = NOTE, buyerStage and sellerStage may be null and
        the entry represents a free-form note on the timeline.
    end note
  }


  '======================
  ' DOCUMENT MANAGEMENT CONTEXT
  '======================
  package "Document Management" as DocumentBC <<Rectangle>> #LightGreen {

    AGGREGATE_ROOT(DocumentRequest) #lightgreen {
      requestId: UUID
      transactionRef: TransactionRef
      side: TransactionSideEnum
      docType: DocumentTypeEnum
      customTitle: String
      status: DocumentStatusEnum
      expectedFrom: DocumentPartyEnum
      relatedBuyerStage: BuyerTransactionStageEnum?
      relatedSellerStage: SellerTransactionStageEnum?
      submittedDocuments: List<SubmittedDocument>
      brokerNotes: String
      lastUpdatedAt: DateTime
      visibleToClient: Boolean
    }

    VALUE_OBJECT(TransactionRef) #Bisque {
      transactionId: UUID
      clientId: UUID
      side: TransactionSideEnum
    }

    VALUE_OBJECT(StorageObjectRef) #Bisque {
      s3Key: String
      fileName: String
      mimeType: String
    }

    ENUM(DocumentPartyEnum) {
      BUYER
      SELLER
      BROKER
      LENDER
      NOTARY
      INSPECTOR
      OTHER
    }

    VALUE_OBJECT(UploadedByRef) #Bisque {
      party: DocumentPartyEnum
      clientId: UUID?
      brokerId: UUID?
      externalName: String?
    }

    ENTITY(SubmittedDocument) #lightpink {
      documentId: UUID
      uploadedAt: DateTime
      uploadedBy: UploadedByRef
      storageObject: StorageObjectRef
    }

    ENUM(DocumentTypeEnum) {
      ' Buyer prequalification
      MORTGAGE_PRE_APPROVAL_LETTER
      BUYER_PROOF_OF_FUNDS
      BUYER_PROOF_OF_INCOME
      BUYER_ID_DOCUMENT

      ' Shared / property docs
      CERTIFICATE_OF_LOCATION
      SELLER_DECLARATION
      MLS_LISTING

      ' Offer and negotiation
      PROMISE_TO_PURCHASE
      OFFER_ANNEX
      ACKNOWLEDGED_SELLER_DECLARATION

      ' Inspection
      INSPECTION_REPORT

      ' Financing and insurance
      FINAL_MORTGAGE_APPROVAL_LETTER
      INSURANCE_CONFIRMATION_LETTER

      ' Notary
      MORTGAGE_DEED
      DEED_OF_SALE
      ACCEPTED_OFFER_PACKAGE
      PRIOR_DEEDS
      CERTIFIED_COPY_OF_DEED

      ' Seller-side supporting docs
      CMA_REPORT
      MUNICIPAL_TAX_BILL
      SCHOOL_TAX_BILL
      MORTGAGE_BALANCE_STATEMENT

      ' Fallback
      OTHER
    }

    ENUM(DocumentStatusEnum) {
      REQUESTED
      SUBMITTED
      APPROVED
      NEEDS_REVISION
    }

    ' Intra-context links
    DocumentRequest "1" *-- "1" TransactionRef
    DocumentRequest "1" *-- "0..*" SubmittedDocument
    SubmittedDocument "1" *-- "1" StorageObjectRef

    DocumentRequest --> DocumentTypeEnum
    DocumentRequest --> DocumentStatusEnum
    DocumentRequest --> DocumentPartyEnum
    DocumentRequest --> BuyerTransactionStageEnum
    DocumentRequest --> SellerTransactionStageEnum

    SubmittedDocument --> DocumentPartyEnum

    note bottom of DocumentRequest
      Invariants:
      • status transitions follow REQUESTED → SUBMITTED → (APPROVED | NEEDS_REVISION).
      • Each DocumentRequest is tied to exactly one Transaction and must
        share the same side as that Transaction.
      • If status = APPROVED, brokerNotes should capture approval context.
      • Each DocumentRequest may have multiple SubmittedDocuments
        representing resubmissions (chain of custody); the latest
        by uploadedAt is considered the current version.
      • When side = BUY_SIDE and a stage link is needed, relatedBuyerStage
        must be non-null and relatedSellerStage must be null.
      • When side = SELL_SIDE and a stage link is needed, relatedSellerStage
        must be non-null and relatedBuyerStage must be null.
    end note

    note bottom of SubmittedDocument
      Invariants:
      • storageObject.s3Key must exist in S3.
      • uploadedBy.party identifies who actually uploaded the document
        (e.g., buyer/seller client, broker, external notary or lender).
      • When uploadedBy.party ∈ {BUYER, SELLER}, clientId must be non-null
        and correspond to the Client bound to transactionRef.
      • When uploadedBy.party = BROKER, brokerId must be non-null.
    end note
  }


  '======================
  ' APPOINTMENT MANAGEMENT CONTEXT
  '======================
  package "Appointment Management" as AppointmentBC <<Rectangle>> #LightSalmon {

    AGGREGATE_ROOT(Appointment) #lightsalmon {
      appointmentId: UUID
      transactionRef: TransactionRef
      clientRef: ClientRefSnapshot
      brokerRef: BrokerRefSnapshot
      appointmentType: AppointmentTypeEnum
      scheduledStart: DateTime
      scheduledEnd: DateTime
      status: AppointmentStatusEnum
      details: String
      lastModifiedByBrokerId: UUID
      reminderPolicy: ReminderPolicy
    }

    VALUE_OBJECT(ClientRefSnapshot) #Bisque {
      clientId: UUID
      clientName: String
      clientEmail: String
    }

    VALUE_OBJECT(BrokerRefSnapshot) #Bisque {
      brokerId: UUID
      brokerName: String
      brokerLicenseNumber: String
    }

    VALUE_OBJECT(ReminderPolicy) #Bisque {
      sendEmailReminder: Boolean
      minutesBefore: Integer
    }

    ENUM(AppointmentTypeEnum) {
      BUYER_SHOWING
      LISTING_VISIT
      INSPECTION
      NOTARY_MEETING
      OTHER
    }

    ENUM(AppointmentStatusEnum) {
      PENDING_BROKER_CONFIRMATION
      CONFIRMED
      CANCELLED
      RESCHEDULE_PROPOSED
      DECLINED
      COMPLETED
    }

    ' Intra-context links
    Appointment "1" *-- "1" TransactionRef
    Appointment "1" *-- "1" ClientRefSnapshot
    Appointment "1" *-- "1" BrokerRefSnapshot
    Appointment "0..1" *-- "1" ReminderPolicy
    Appointment --> AppointmentTypeEnum
    Appointment --> AppointmentStatusEnum

    note bottom of Appointment
      Invariants:
      • Each Appointment is associated with exactly one Transaction.
      • scheduledStart must be in the future when status is
        PENDING_BROKER_CONFIRMATION or CONFIRMED.
      • ReminderPolicy governs when email reminders are sent.
    end note
  }


  '======================
  ' NOTIFICATIONS CONTEXT
  '======================
  package "Notifications" as NotificationsBC <<Rectangle>> #Thistle {

    AGGREGATE_ROOT(OutboundNotification) #Thistle {
      notificationId: UUID
      recipientEmail: String
      subject: String
      body: String
      channel: NotificationChannelEnum
      relatedEntity: RelatedEntityRef
      sentAt: DateTime
      status: NotificationStatusEnum
      providerMessageId: String
    }

    VALUE_OBJECT(RelatedEntityRef) #Bisque {
      entityType: RelatedEntityTypeEnum
      entityId: UUID
    }

    ENUM(NotificationChannelEnum) {
      EMAIL
      SMS
    }

    ENUM(NotificationStatusEnum) {
      PENDING
      SENT
      FAILED
    }

    ENUM(RelatedEntityTypeEnum) {
      TRANSACTION
      DOCUMENT_REQUEST
      APPOINTMENT
    }

    ' Intra-context links
    OutboundNotification "1" *-- "1" RelatedEntityRef
    OutboundNotification --> NotificationChannelEnum
    OutboundNotification --> NotificationStatusEnum
    RelatedEntityRef --> RelatedEntityTypeEnum

    note bottom of OutboundNotification
      Invariants:
      • channel = EMAIL is fulfilled via Amazon SES.
      • Each notification references a meaningful business entity
        (Transaction, DocumentRequest, Appointment).
    end note
  }


  '======================
  ' ANALYTICS CONTEXT
  '======================
  package "Analytics" as AnalyticsBC <<Rectangle>> #LightGray {

    AGGREGATE_ROOT(BrokerMetricsSnapshot) #lightgray {
      snapshotId: UUID
      brokerRef: BrokerRefForMetrics
      capturedAt: DateTime
      activeTransactionsCount: Integer
      activeBuyerTransactionsCount: Integer
      activeSellerTransactionsCount: Integer
      avgTimeToCloseDays: Decimal
      documentsAwaitingReviewCount: Integer
      pendingAppointmentsCount: Integer
    }

    VALUE_OBJECT(BrokerRefForMetrics) #Bisque {
      brokerId: UUID
      brokerName: String
    }

    note bottom of BrokerMetricsSnapshot
      Invariants:
      • Represents a point-in-time view used by broker dashboards.
      • activeTransactionsCount counts Transaction.status = ACTIVE.
      • activeBuyerTransactionsCount counts ACTIVE Transactions
        where side = BUY_SIDE.
      • activeSellerTransactionsCount counts ACTIVE Transactions
        where side = SELL_SIDE.
      • avgTimeToCloseDays derived from Transaction.openedAt → closedAt.
      • documentsAwaitingReviewCount counts DocumentRequests with
        status ∈ {REQUESTED, SUBMITTED} awaiting broker action.
      • pendingAppointmentsCount counts Appointment.status in
        {PENDING_BROKER_CONFIRMATION, RESCHEDULE_PROPOSED}.
    end note
  }


  '======================
  ' CROSS-CONTEXT RELATIONSHIPS
  '======================

  ' TRANSACTION ↔ USER MANAGEMENT
  TransactionBC.Transaction --> UserBC.ClientIdentifier
  TransactionBC.Transaction --> UserBC.BrokerIdentifier
  note on link
    Transaction references the Client and Broker
    responsible for that specific real estate case.
    Snapshots are stored in ClientRef and BrokerRef
    to preserve historical context.
  end note

  ' DOCUMENT MANAGEMENT ↔ TRANSACTION MANAGEMENT
  DocumentBC.DocumentRequest --> TransactionBC.TransactionIdentifier
  note on link
    A DocumentRequest always belongs to exactly
    one Transaction and is part of that transaction's
    compliance and progress requirements.
  end note

  ' APPOINTMENT MANAGEMENT ↔ TRANSACTION MANAGEMENT
  AppointmentBC.Appointment --> TransactionBC.TransactionIdentifier
  note on link
    Appointments are always attached to a Transaction
    and represent buyer/seller meetings, inspections,
    notary visits, and other key events.
  end note

  ' APPOINTMENT MANAGEMENT ↔ USER MANAGEMENT (snapshots)
  AppointmentBC.ClientRefSnapshot --> UserBC.ClientIdentifier
  AppointmentBC.BrokerRefSnapshot --> UserBC.BrokerIdentifier
  note on link
    Appointments embed snapshot data (name, license)
    so historical appointment records remain accurate
    even if Client or Broker details change later.
  end note

  ' NOTIFICATIONS ↔ DOCUMENT / TRANSACTION / APPOINTMENT
  NotificationsBC.OutboundNotification --> DocumentBC.DocumentRequest
  NotificationsBC.OutboundNotification --> TransactionBC.Transaction
  NotificationsBC.OutboundNotification --> AppointmentBC.Appointment
  note on link
    Notifications are triggered when meaningful
    business actions occur, such as:
    • stage change,
    • document approved / needs revision,
    • appointment confirmed / rescheduled.
  end note

  ' ANALYTICS ↔ TRANSACTION / DOCUMENT / APPOINTMENT
  AnalyticsBC.BrokerMetricsSnapshot --> TransactionBC.Transaction
  AnalyticsBC.BrokerMetricsSnapshot --> DocumentBC.DocumentRequest
  AnalyticsBC.BrokerMetricsSnapshot --> AppointmentBC.Appointment
  note on link
    Metrics are computed from live operational data:
    - activeTransactionsCount
    - documentsAwaitingReviewCount
    - pendingAppointmentsCount
    These KPIs feed the broker dashboard.
  end note

}

@enduml
